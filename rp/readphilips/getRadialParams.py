# -*- coding: utf-8 -*-
"""This is a library of routines for reading in and
populating a dictionary of the parameters needed for
radial reconstruction.

This script was generated by JWP on 2022-04-06, with 
the goal of imitating the getSpiralParams.py function. 
"""

# Import modules:
import numpy as np

        
def processRadialParams(header):
    radparams = dict()
    radparams['headerType'] = 'radparams'
    hdr = None       
    radial_traj = False
    if header['headerType'] == 'lab-sin':
        hdr = header['sin']
        if 'k_space_traj_type' in hdr:
            radial_traj = (int(float(hdr['k_space_traj_type'][0][0])) == 1) # k_space_traj_type = 1 for radial, 2 for spiral.
        
            if radial_traj == True:
                # Print a statement telling the user that radial coordinate parameters are being calculated.
                print('Radial coordinate parameters will be contained in: radparams.')
  
        else:
            print('WARNING: Could not find k_space_traj_type in .sin.') 
            radial_traj = False
            
            
# =============================================================================
# # IMPORTANT NOTE: JWP - 2022-04-06
# I have added the 'except' evaluations for each variable here using the 
# default values set by GPI.            
# =============================================================================
    if radial_traj == True:
        try:
            nsamp = int(
                        float(hdr['non_cart_max_encoding_nrs'][0][0]) -
                        float(hdr['non_cart_min_encoding_nrs'][0][0]) +
                        1)
            radparams['NR_SAMPLES'] = nsamp
        except:
            print("WARNING: non_cart_[max/min]_encoding_nrs not found"\
                + " in .sin file. Defaulting to current widget value.")
            nsamp = 256

        try:
            nprof = int(float(
                hdr['non_cart_max_encoding_nrs'][0][1]) + 1)
            radparams['NR_PROFILES'] = nprof
        except:
            print("WARNING: non_cart_max_encoding_nrs not found"\
                + " in .sin file. Defaulting to current widget value.")
            nprof = 200
        try:
            mode = int(float(hdr['non_cart_3d'][0][0]))
            radparams['THREE_DIMENSIONS'] = mode
        except:
            print("WARNING: non_cart_3d not found in .sin file."\
                + " Defaulting to current widget value.")
            mode = 1
        try:
            fid_samp = int(float(hdr
                ['non_cart_fid_sampling'][0][0]))
            radparams['FID_SAMPLING'] = fid_samp
        except:
            print("WARNING: non_cart_fid_sampling not found in .sin"\
                + " file. Defaulting to non FID sampling.")
            fid_samp = 1
            
        if mode:
            try:
                interleaves = int(float(
                    hdr['non_cart_max_encoding_nrs'][0][2]) + 1)
                radparams['NR_INTERLEAVES'] = interleaves
            except:
                print("WARNING: non_cart_max_encoding_nrs not found"\
                + " in .sin file. Defaulting to current widget value.")
                interleaves = 10
                    
        if fid_samp: # UTE ramp sampling
            try:
                necho = int(float(hdr['nr_echoes'][0][0]))
                radparams['NR_ECHOES'] = necho
            except:
                print("WARNING: nr_echoes not found in .sin file."\
                  + " Defaulting to current widget value.")
                necho = 1
            if necho == 2:
                try:
                    nsamp2 = int(
                                float(hdr['non_cart_max_encoding_nrs'][0][4]) -
                                float(hdr['non_cart_min_encoding_nrs'][0][4]) +
                                1)
                    radparams['NR_SAMPLES_2ND_ECHO'] = nsamp2
                except:
                    print("WARNING: non_cart_[max/min]_encoding_nrs not found"\
                          + " for second echo in .sin file. Defaulting to"\
                          + " first echo value.")
                    nsamp2 = 256
            try:
                delay = float(hdr['non_cart_fid_delay'][0][0])
                radparams['DELAY'] = delay
            except:
                print("WARNING: non_cart_fid_delay not found in .sin file."\
                    + " Defaulting to current widget value.")  
                delay = 0
            try:
                slope = float(hdr['non_cart_fid_slope'][0][0])
                radparams['SLOPE'] = slope
            except:
                print("WARNING: non_cart_fid_slope not found in .sin file."\
                    + " Defaulting to current widget value.")       
                slope = 0
            try:
                smoother = float(hdr['non_cart_fid_smoother'][0][0])
                radparams['SMOOTHER'] = smoother
            except:
                print("WARNING: non_cart_fid_smoother not found in .sin"\
                      + " file. Defaulting to current widget value.")  
                smoother = 0
            try:
                ntrail = np.maximum(0, int(np.ceil(-float(hdr
                ['non_cart_fid_trailing_sample'][0][0]))))
                radparams['NR_TRAILING_SAMPLES'] = ntrail
            except:
                print("WARNING: non_cart_fid_trailing_sample not found in"\
                      + " .sin file. Defaulting to current widget value.")
                ntrail = 0
            
                    
                    
        # Now the variables are initialized, calculate gradients:
        FILTER_TAPS = 5
        radparams['FILTER_TAPS'] = FILTER_TAPS
        
        flyback = 0 # Assume equal to 0, we may want to change this. 
        radparams['FLYBACK'] = flyback
        
        if fid_samp: # UTE ramp sampling
            
        # Define start and end points of gradient ramp and sampling
            int_ratio_1 = int(FILTER_TAPS * smoother - delay)
            int_ratio_2 = int(np.ceil(delay - smoother))
            int_ratio_3 = int(np.ceil(delay - smoother) + np.ceil(slope))
            start_slope = np.maximum(0, int_ratio_2 + int_ratio_1)
            radparams['START_SLOPE'] = start_slope
            end_slope = np.maximum(0, int_ratio_3 + int_ratio_1)
            radparams['END_SLOPE'] = end_slope

            # Theoretical gradient waveform with padding for filter convolution
            grad = np.zeros(nsamp+ntrail+int_ratio_1)
            grad[0:start_slope] = 0.0
            grad[start_slope:end_slope] = (np.arange(int_ratio_2,
                                           int_ratio_3) - (delay-smoother))
            if slope > 0:
                grad[end_slope:] = slope
            else:
                grad[end_slope:] = 1.0
            radparams['THEORETICAL_GRADIENT'] = grad

            # Apply the filter
            if smoother > 0:
                filt = np.exp(-np.arange(int(np.ceil(FILTER_TAPS *
                    smoother))) / smoother)
                if len(filt) > 0:
                    grad_filt = np.convolve(grad, filt)
                else:
                    grad_filt = grad
            else:
                grad_filt = grad
            radparams['FILTERED_GRADIENT'] = grad_filt

            # Generate k-space locations from the gradient samples
            kr = np.cumsum(grad_filt)[int_ratio_1:int_ratio_1+nsamp+ntrail]
            norm_fact = 0.5 * ((nsamp + ntrail - 1) /
                ((nsamp + ntrail) * kr[nsamp + ntrail - 1]))
            kr = kr[:nsamp] * norm_fact
            # else: # no slope must mean uniform sampling out from center
            #     kr = np.linspace(0, 0.5, nsamp, endpoint=False)
            
            # Account for flyback in second-echo
            if necho == 2:
                kr2 = np.linspace(-0.5, 0.5, nsamp2, endpoint=False)
                if nsamp2 != nsamp:
                    flyback = 1
        else: # Assume uniform sampling over the gradient plateau
            kr = np.linspace(-0.5, 0.5, nsamp, endpoint=False) 
            
        
        # Now, calculate coordinates:
        if mode == 0: # 2D
            if fid_samp: # Uniform angles over 360 degrees
                theta = 2.0 * np.pi * np.arange(nprof) / nprof
            else: # Unifom angles over 180 degrees
                theta = np.pi * np.arange(nprof) / nprof
            radparams['THETA_2D'] = theta
            coords = np.zeros([nprof, nsamp, 2])
            coords[:, :, 0] = np.outer(np.cos(theta), kr)
            coords[:, :, 1] = np.outer(-np.sin(theta), kr)
            radparams['COORDS'] = coords
            if fid_samp and flyback:
                coords2 = np.zeros([nprof, nsamp2, 2])
                coords2[:, :, 0] = np.outer(np.cos(theta), kr2)
                coords2[:, :, 1] = np.outer(-np.sin(theta), kr2)
                radparams['COORDS_FLYBACK'] = coords2
        else: # 3D
            # generate phi and theta 3D rotation values
            phi = 2 * np.pi * np.arange(interleaves) / interleaves
            phi.shape = [interleaves, 1]
            phi = np.tile(phi, (1, nprof))
            if fid_samp:
                z = (2 * np.arange(nprof) + 1 - nprof) / np.float32(nprof)
                z = np.tile(z, (interleaves, 1))
                z[1::2,:] = -z[1::2,:]
                phi = (phi + np.sqrt(nprof * np.pi / interleaves) *
                       np.arcsin(z))
            else:
                z = (np.arange(nprof) + 0.5 - nprof) / np.float32(nprof)
                z = np.tile(z, (interleaves, 1))
                phi = (phi + np.sqrt(2.0 * nprof * np.pi / interleaves) *
                       np.arcsin(z))
            radparams['PHI'] = phi
            cp = np.cos(phi)
            sp = np.sin(phi)
            st = np.sqrt(1.0 - z * z)
            coords = np.zeros([interleaves, nprof, nsamp, 3])
            outdims = [interleaves, nprof, nsamp]
            coords[:,:,:,0] = np.reshape(np.outer(cp * st, kr), outdims)
            coords[:,:,:,1] = np.reshape(np.outer(sp * st, kr), outdims)
            coords[:,:,:,2] = np.reshape(np.outer(z, kr), outdims)
            radparams['COORDS'] = coords
            if fid_samp and flyback:
                coords2 = np.zeros([interleaves, nprof, nsamp2, 3])
                outdims2 = [interleaves, nprof, nsamp2]
                coords2[:,:,:,0] = np.reshape(np.outer(cp * st, kr2), outdims2)
                coords2[:,:,:,1] = np.reshape(np.outer(sp * st, kr2), outdims2)
                coords2[:,:,:,2] = np.reshape(np.outer(z, kr2), outdims2)
                radparams['COORDS_FLYBACK'] = coords2
                   

    return(radparams)